# CLAUDE.md

이 파일은 Claude Code (claude.ai/code)가 이 저장소에서 작업할 때 필요한 가이드를 제공합니다.

## 개발 명령어

### 핵심 개발 명령어
```bash
# 전체 개발 환경 시작 (API 서버 + Vite 개발 서버)
pnpm dev

# 프론트엔드 개발 서버만 시작
pnpm start

# API 서버 자동 재시작으로 시작
pnpm run server:watch

# 프로덕션 빌드
pnpm build
```

### 테스트
```bash
# 감시 모드로 테스트 실행
pnpm test

# 모든 테스트 한 번 실행
pnpm test run

# 특정 테스트 파일 실행
pnpm test -- src/__tests__/hooks/useEventOperations.test.ts

# UI로 테스트 실행
pnpm test:ui

# 커버리지 리포트 생성
pnpm test:coverage
```

### 코드 품질
```bash
# 모든 린팅 실행 (ESLint + TypeScript)
pnpm lint

# ESLint만 실행
pnpm lint:eslint

# TypeScript 체크만 실행
pnpm lint:tsc
```

## 아키텍처 개요

React 캘린더 애플리케이션으로 다음 아키텍처 패턴을 따릅니다:

### 컴포넌트 구조
- **유연한 컴포넌트 설계**: 필요에 따라 단일 컴포넌트(`App.tsx`) 또는 분리된 컴포넌트 구조 선택 가능
- **현재 구조**: 전체 UI가 `App.tsx`에 포함된 단일 컴포넌트 구조
- **분리 허용**: 복잡한 기능 추가 시 `components/` 폴더로 UI 컴포넌트 분리 가능
- **커스텀 훅 구성**: 비즈니스 로직이 `src/hooks/`의 전문 훅들로 분리됨
- **유틸리티 기반 아키텍처**: 순수 함수들이 `src/utils/`로 분리됨

### 주요 커스텀 훅
- `useCalendarView`: 캘린더 네비게이션과 뷰 상태 관리 (월/주)
- `useEventOperations`: API를 통한 이벤트 CRUD 작업 처리
- `useEventForm`: 이벤트 생성/편집을 위한 폼 상태 및 검증 관리
- `useNotifications`: 시간 기반 이벤트 알림 처리
- `useSearch`: 이벤트 필터링 및 검색 기능 제공

### 데이터 흐름
1. **API 계층**: Express 서버 (`server.js`)가 JSON 파일 저장소에서 이벤트를 제공
2. **훅 계층**: 커스텀 훅들이 상태와 API 상호작용을 관리
3. **컴포넌트 계층**: 단일 App 컴포넌트가 훅들을 사용하고 UI를 렌더링
4. **유틸리티 계층**: 순수 함수들이 날짜 계산, 검증, 변환을 처리

### 테스트 전략
- **MSW 통합**: `src/__mocks__/handlers.ts`의 핸들러를 사용한 API 모킹
- **테스트 분류**: 유틸리티 단위 테스트, `@testing-library/react-hooks`를 사용한 훅 테스트, 사용자 워크플로우 통합 테스트
- **시간 제어**: 테스트에서 가짜 타이머와 제어된 시스템 시간 사용 (2025-10-01 기준)

### 설정 세부사항
- **빌드 도구**: 빠른 컴파일을 위한 React SWC 플러그인과 Vite
- **프록시 설정**: 개발 중 `/api` 라우트를 localhost:3000으로 프록시
- **TypeScript**: 프로젝트 참조와 함께 Strict 모드 활성화
- **패키지 매니저**: 10.15.0 버전으로 잠긴 pnpm

### 이벤트 데이터 구조
이벤트는 `Event` 인터페이스를 따름:
- 기본 정보: title, date, startTime, endTime, description, location, category
- 반복 기능: type (none/daily/weekly/monthly/yearly), interval, endDate
- 알림: 이벤트 전 분 단위로 저장되는 시간 기반 알림

### 개발 vs 테스트 환경
- **개발**: 파일 기반 지속성을 가진 실제 Express 서버 사용
- **테스트**: 예측 가능한 테스트 조건을 위한 인메모리 모킹과 MSW 사용

## 중요 파일 위치

- `src/types.ts`: Event, EventForm, RepeatInfo의 핵심 TypeScript 인터페이스
- `src/__mocks__/handlers.ts`: 테스트용 MSW API 핸들러
- `src/__mocks__/response/realEvents.json`: 개발 데이터 저장소
- `src/setupTests.ts`: MSW 설정이 포함된 테스트 환경 구성
- `vite.config.ts`: 빌드 및 테스트 구성
- `server.js`: 개발 API 서버

---

## 코딩 스타일 가이드

### 네이밍 컨벤션 (MANDATORY)
```typescript
// 폴더명: kebab-case 복수형
// folders/
// components/
// custom-hooks/

// 컴포넌트, Type, Interface: PascalCase
export interface EventForm { }
export const CalendarHeader = () => { }

// 훅, 유틸리티 함수: camelCase
export const useEventOperations = () => { }
export const formatDate = () => { }

// 상수: SCREAMING_SNAKE_CASE
export const API_ENDPOINTS = {
  EVENTS: '/api/events'
}
```

### 함수형 프로그래밍 원칙
- **화살표 함수 우선**: `const fn = () => {}` 형태 사용
- **ES6+ 적극 활용**: 구조분해, 전개연산자, 템플릿리터럴, 옵셔널체이닝
- **순수 함수 지향**: 사이드 이펙트 최소화, 예측 가능한 결과
- **타이핑 전략**: 매개변수와 복잡한 반환값은 명시적, 간단한 변수는 추론 활용

## 개발 원칙

### 컴포넌트 설계
- **단일 책임 원칙**: 함수/컴포넌트당 하나의 명확한 목적
- **작은 컴포넌트**: 가독성을 위해 큰 컴포넌트보다 작은 단위 선호
- **Props 설계**: 
  - 엔티티 컴포넌트: 구체적 설계 (Event-specific props)
  - UI 컴포넌트: 유연한 설계 (generic, reusable props)
- **재사용성**: 3회 이상 반복 시에만 추상화 고려, 그 전까지는 가독성 우선

### 아키텍처 선택
[//]: # (- **폴더 구조**: 기능별이 아닌 타입별 구성 &#40;`hooks/`, `utils/`, `components/`&#41;)
- **Import 전략**: 절대 경로 선호 (`src/utils/dateUtils` vs `../utils/dateUtils`)
- **Barrel Exports**: 사용하지 않음 (명시적 import 선호)

[//]: # (- **상태관리**: Context API보다 Jotai 선호 &#40;현재 프로젝트는 단일 컴포넌트 구조&#41;)

## 코드 품질 기준

### 우선순위별 체크리스트
1. **네이밍 (최우선)**: 명확하고 의도가 드러나는 이름
2. **함수 길이**: 줄 수보다 단일 책임 준수 여부가 중요
3. **중복 코드**: 공통 함수 추출 (3회 이상 반복 시)
4. **에러 처리**: 방어적 프로그래밍, 명확한 에러 메시지
5. **성능**: 필요 시에만 메모이제이션 (측정 후 최적화)

### 품질 지표
- **정성적 원칙 > 정량적 기준**: 줄 수보다 응집도와 결합도 균형
- **ESLint 준수**: 엄격한 룰 적용, 예외는 주석으로 정당화
- **주석 스타일**: 인라인 우선, 과도한 JSDoc 지양

## AI 작업 규칙

### 디자인 보존 정책 (CRITICAL)
- **기존 스타일 유지**: 사용자가 명시적으로 요청하지 않는 한 UI/스타일 변경 금지
- **클래스명 보존**: 기존 CSS 클래스, 스타일링, 레이아웃 유지
- **기능적 개선만**: 비즈니스 로직과 기능 개선에만 집중
- **사전 확인**: 스타일 변경이 필요한 경우 사용자에게 먼저 확인

### 직설적 피드백 정책
- **정확성 > 예의**: 잘못된 코드나 비효율적인 부분을 명확하게 지적
- **구체적 문제 명시**: "이 부분이 문제입니다", "이렇게 하면 버그가 발생할 수 있습니다"
- **개선 방안 제시**: 문제점과 함께 올바른 해결 방법 제공
- **베스트 프랙티스 강조**: 업계 표준과 다를 때 적극적으로 알림

### 의도 파악 및 방향성
- **진짜 목적 파악**: "이 코드는 XX를 하려고 하는 것 같은데 맞나요?"
- **숨겨진 의도 추론**: 겉으로 보이는 것 외에 실제 달성하려는 목표 파악
- **방향성 명확화**: 현재 접근법이 원하는 결과에 적합한지 확인
- **더 나은 접근법**: 목적에 맞는 더 효과적인 방법 제안

## TDD 및 구현 가이드라인

### 핵심 철학
- **점진적 발전 > 대규모 변경**: 컴파일되고 테스트를 통과하는 작은 변화들
- **기존 코드로부터 학습**: 구현하기 전에 연구하고 계획하기
- **실용적 > 교조적**: 프로젝트 현실에 맞춰 적응하기
- **명확한 의도 > 영리한 코드**: 지루하고 명백하게 작성하기

### 구현 프로세스
1. **이해**: 기존 패턴 연구 및 코드베이스 학습
2. **테스트**: 테스트 먼저 작성 (Red)
3. **구현**: 통과하는 최소한의 코드 (Green)
4. **리팩토링**: 테스트 통과 상태에서 정리 (Refactor)
5. **커밋**: 계획과 연결된 명확한 메시지

### 막혔을 때 규칙 (3회 제한)
**중요**: 이슈당 최대 3회 시도 후 중단

1. **실패 문서화**: 시도한 것, 구체적 에러, 실패 원인 추정
2. **대안 연구**: 유사한 구현 2-3개 찾기, 다른 접근 방식 기록
3. **근본적 질문**: 올바른 추상화 수준인가? 더 작은 문제로 나눌 수 있는가?
4. **다른 각도**: 다른 라이브러리/패턴/아키텍처 시도

### 완료 정의 (모든 커밋은 반드시)
- ✅ 성공적으로 컴파일
- ✅ 기존 테스트 모두 통과  
- ✅ 새로운 기능에 대한 테스트 포함
- ✅ `pnpm lint` 통과 (포맷팅/린팅 규칙 준수)
- ✅ 커밋 메시지가 "왜"를 설명

### 금지사항
- `--no-verify` 사용하여 커밋 훅 우회
- 테스트 수정 대신 비활성화  
- 컴파일되지 않는 코드 커밋
- 추정하기 (항상 기존 코드로 검증)
- 설명이 필요한 영리한 코드 작성

### 의사결정 프레임워크
여러 접근법이 있을 때 다음 기준으로 선택:
1. **테스트 가능성**: 쉽게 테스트할 수 있는가?
2. **가독성**: 6개월 후에 누군가 이해할 수 있는가?
3. **일관성**: 프로젝트 패턴과 맞는가?
4. **단순성**: 작동하는 가장 간단한 해결책인가?
5. **되돌릴 수 있음**: 나중에 바꾸기 얼마나 어려운가?